
from django.shortcuts import render,redirect
from django.http import HttpResponse, JsonResponse
from django.views.decorators.csrf import ensure_csrf_cookie
from .models import Game,PlayerUser,Board ,Question
from random import randint
import logging
from django.contrib.auth import authenticate, login, logout, get_user_model
from django.contrib.auth.decorators import login_required
from django.contrib.auth import get_user_model, login, logout
from django.contrib.auth.decorators import login_required
###for get_current_users()
from django.contrib.auth.models import User
import requests
from django.contrib import auth
from django.contrib.auth.models import User
from datetime import timedelta, datetime
from django.utils import timezone

import functools
from contextlib import ContextDecorator
from datetime import datetime, timedelta, tzinfo
from threading import local

import pytz

from django.conf import settings


import json

usr = get_user_model()
print("yayyy")
#print(request.user)
logger = logging.getLogger('GAME')
UP=0
DOWN=1
LEFT=2
RIGHT=3
#@ensure_csrf_cookie

def get_default_timezone():
    """
    Return the default time zone as a tzinfo instance.

    This is the time zone defined by settings.TIME_ZONE.
    """
    return pytz.timezone(settings.TIME_ZONE)



# This function exists for consistency with get_current_timezone_name
def get_default_timezone_name():
    """Return the name of the default time zone."""
    return _get_timezone_name(get_default_timezone())

_active = local()


def get_current_timezone():
    """Return the currently active time zone as a tzinfo instance."""
    return getattr(_active, "value", get_default_timezone())


#@login_required
def timer(user_):
    # if request.user.is_authenticated():
    #print("yayyy")
    user_.time = float(7200-(timezone.now()-user_.regTime).total_seconds())
    current_time =  datetime.now()
    #user_.time = current_time1.hour*3600 + current_time1.minute*60 + current_time1.second
    print("yoyoyo")
    # print(timezone.now() ," ",get_current_timezone()," ", datetime.now()," ",user_.regTime)
    print("timezone.now()-user_.regTime : ", (timezone.now()-user_.regTime).total_seconds())
    # print(user_.time)
    # print("regTime")
    # print(user_.regTime.time)
    # print((timezone.now()-user_.regTime).total_seconds())
    user_.save()
    # return HttpResponse("yoyaayy")
    return float(user_.time)


#@login_required(login_url='/login/')
def apogee(request):
    print("calling index")
    
    game = Game()

    games = Game.objects.all()

    return render(request, 'apogee.html', {'games': games})


#@login_required(login_url='/login/')
def Acads(request):
    print("calling index")
    
    game = Game()

    games = Game.objects.all()

    return render(request, 'db.html', {'games': games})

#@login_required(login_url='/login/')
def do(request):
    print("calling do")
    if request.method == 'GET':    # page is called by 'get' request
        #dta = json.loads(request.body)
        #request.user.face = dta['faceselected'] 
        #request.user.save()
        #print("get")
        print(request.user)
        #print(request.user.face)
        return create()

    elif request.method == 'POST': #directions are taken by 'post' request
        if(timer(request.user)<0):
            print("Time Over")
            #print(timer(request.user))
            #logout(request)
            return redirect('/')
        #revealQues(request)
        
        #{'answer': ,'userw': ,'board_state':false}
        #{'board': ,'direction'}
        print("post")
        print(request)
        logger.info(request.body)
        print("request")
        print(request.body)  
        global current_player 
        #current_player = request.user  
        #current_player = PlayerUser.objects.create(name = request.user)  
        print(request.user.score)   
        print(request.user)
        data = json.loads(request.body)  # parsing json string {'data','direction'}    ***here face choosen is req from frontend
        print(data)      # {"board":[0,0,2,0,0,0,0,0,0,0,0,0,0,2,0,0],"direction":0, "board_state":True/False}     
        # if(data['board_state']!=False):
        #     return process(data,request.user)
        return process(data,request.user,request)
    return create()

#@login_required(login_url='/login/')
def process(data,user_,request):
    print("calling process")
    # oasis = 0, apogee = 1, blah blah = 2,blah blah = 3, blah blah = 4, blah blah = 5, blah blah = 6

    # dict_ = revealQues(request)
    if data['board_state']==True:
        board = data['board']
        direction = data['direction']
        #user.face = data['faceselected']  #***from frontend
        #user.save()

        user_score = user_.score
        #Collapse by direction
        #collapse(board,direction,current_player, current_player_face_selected)
        print("*************************************************************")
        collapse(board,direction,user_)
        #Add new element
        lose = addNew(board)
        #Build response
    
        response = {}
        count = (7200-request.user.time)/(request.user.currentQs*40)
        if(count >=1 ):
            revealQues_dict = revealQues(request)
            response['board_state'] = False
            response['curr_ques_Ques'] = revealQues_dict['curr_ques_Ques']
        else:
            response['board_state'] = True
        response['board'] = board
        response['continue'] = (lose==False)
        response['score'] = user_score
        
        print("response : ",response)     #response :  {'board': [0, 2, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 'continue': True, score : 200}
        logger.info(response)
        return JsonResponse(response,safe=False)    # *** to frontend
    
    # else is executed when user clicks at that time when ques needs to be displayed
    # frontend sends {"answer":__ , 'user':__}
    else:
        user_answer = data['answer']
        user_ = data['user_']

        checkAnswer_dict_ =  checkAnswer(request)
        response = {}
        response['board'] = board
        response['continue'] = (lose==False)
        response['score'] = checkAnswer_dict_['score']
        response['board_state'] = True
        print("CHECKING THE ANS SCORE",response['score'])
        return JsonResponse(response,safe=False)
        
#@login_required(login_url='/login/')
def collapse(board,direction,user_):
    print("calling collapse")
    collapsed = False
    for i,e in enumerate(board):
        print(board)
        print(i)
        j = nextIndex(i,direction)  # i is index in nextIndex(index,direction)
        print("j value")
        print(j)
        print(board[i])
        
        if j>=0 and j <=15:
            print(board[j])
            if board[i] == board[j] and board[i] != 0:
                
                logger.info("Collapsing %d,%d in %d and %d" % (board[i],board[j],i,j))
                collapseResult(board,i,j,user_)
                #collapseResult(board,i,j)
                collapsed= True
            if board[j] != 0 and board[i] == 0:
                
                logger.info("Collapsing zeros %d,%d in %d and %d" % (board[i],board[j],i,j))
                collapseZeroResult(board,i,j,user_)
                collapsed= True
    if collapsed == True:
        collapse(board,direction,user_)

#@login_required(login_url='/login/')
def collapseResult(board,i,j,user_):
    print("calling collapseResult")
    board[i] = board[i]*2;
    board[j] = 0
    print("summmmm")
    #print(board[i] + board[i])
    user_.score = user_.score + board[i]
    user_.save()
    print(user_.score)
    #current_player.score = current_player.score +  board[i]
    #print(current_player.score)
    #current_player.save()

#@login_required(login_url='/login/')
def collapseZeroResult(board,i,j,user_):
    print("calling collapseZeroResult")
    board[i] = board[j];
    board[j] = 0

#Position board
# 00 01 02 03
# 04 05 06 07
# 08 09 10 11
# 12 13 14 15
#@login_required(login_url='/login/')
def nextIndex(index,direction):
    print("calling nextIndex")

    if direction == UP:
        return index +4
    elif direction == DOWN:
        return index -4
    elif direction == LEFT:
        if (index+1) % 4 ==0:
            return -1
        return index+1
    elif direction == RIGHT:
        if index  % 4 ==0:
            return -1
        return index-1

#@login_required(login_url='/login/')
def addNew(board):
    #Search free spots
    print("calling addNew")
    free = []
    for i,e in enumerate(board):
        print(i,e)
        if e==0:
            free.append(i)
    #Asign 2 to a random free spots
    if len(free) >0 :
        i = randint(0,len(free)-1)
        print("Next spot index %d of %d"% (i,len(free)))
        print("Next spot in %d" % (free[i]))
        board[free[i]] = 2
        return False
    else:
        return True
    
#@login_required(login_url='/login/')
def create():
    print("calling create")
    #Create a new board with random 2 spots
    data =[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    first = randint(0,15)
    second = randint(0,15)
    while first == second:
        second = randint(0,15)
    data[first] = 2
    data[second] = 2
    #data[player] = user;   ***if req by frontend
    print("wohooo")
    return JsonResponse(data,safe=False)    

#@login_required(login_url='/login/')
def revealQues(request):
    
    data = {}
    count = (7200-request.user.time)/(request.user.currentQs*40)
    if(count >=1 ):
        curr_ques = Question.objects.get(questionno = request.user.currentQs)
        data['curr_ques_num'] = curr_ques.questionno
        data['curr_ques_Ques'] = curr_ques.question
        #data['curr_ques_ans'] = curr_ques.solution
        data['board_state'] = False
        request.user.currentQs = request.user.currentQs + 1
        request.user.save()
        print(data)

        #checkAnswer(request)
        return data
 
#@login_required(login_url='/login/')
def checkAnswer(request):
    #if not request.user.is_authenticated() :
    #   return redirect('/main/login')
    # if(timer(request.user)<0):
    #   logout(request)
        # return redirect('/')
    
    if request.method == 'POST':
        #if(timer(request)<0):
            #return JsonResponse
        dt = json.loads(request.body.decode('utf-8'))
        answer = dt['answer']
        print("FRONTEND KA ANS",answer)
        # response['board_state'] = True
        qsno = request.user.currentQs - 1
        qs=Question.objects.get(questionno=qsno)
        #print(answer)
    
        if qs.solution==answer:

            request.user.score+=10000
            print("CHECKING THE ANS SCORE",request.user.score)
            user.currentQs +=1;
            # print("s")
            print(qs.solution)
            request.user.save()
            #return redirect("mainpage/")
            dict_ = {}
            dict_['score'] = request.user.score
            dict_['user'] = request.user.name
            print("CHECKING THE ANS SCORE",dict_['score'])
            return dict_
    
        request.user.save()
        #return redirect("mainpage/")
        return JsonResponse({'user':request.user.name, 'score':request.user.score})

    else:
        return HttpResponse("yayyy")
